# Approaching Problems

It's time to put your group to the test!

The goal of collaborative problem solving is gather a variety of experts and create new and hybrid lenses for understanding your problem. Then to invent solution methods that grow from this new understanding.

To do this, you can't jump right into creating your solution.  The first thing you'll have to do is carefully define the problem you're trying to address taking into account the diverse perspectives and experiences in your group.

This may feel like a waste of time when you already know how to solve the problem, but remember that isn't the point of collaborative problem solving!  You're not managing a team to implement your solution, you're working with other experts to find novel ways of solving your problem.

You can't find a truly novel solution without a truly novel perspective.

### Index
* [analysis first](#analysis-first)
* [constraints](#constraints)   
* [common constraints](#common-constriants)  
* [decomposition](#decomposition)
* [activity](#activity)
* [resources](#resources)

___
## Analysis First

When presented with a new problem, it is a waste of time to start by trying to solve it.  The moment you begin thinking of solutions, you limit your energies to debating or improving the proposed solutions rather than looking for new perspectives on the problem.

Before even considering solutions, you should spend more time than you want to conidering the problem from every angle. This is also not intuitive, but a crucial skill to understand and practice.

As a developer, you are very rarely solving a problem that has been exactly solved before (or you'd be using someone else's code).  You will rarely have much guidance.  You will often have have a lot of freedom in coming up with your solution.  This is not the best situation for creative problem solving.

You must manage your time and your patience to maximize your efforts.  By spending extra time understading the problem then even more selecting the correct constraints for yourself, you will be saving yourself and your team time in the future.

> “Given one hour to save the world, I would spend 55 minutes defining the problem and 5 minutes finding the solution.” ~ Albert Einstein

[TOP](#index)
___
## Constraints

Constraints force you to commit to one path and follow it through.  They force you to think creatively in order to work around them.  They force you to focus your energies onto a smaller set of possible solutions. Adding constraints improves and accelerates creative problem solving.

It may sound intuitively wrong, but the fewer restrictions you have on your work the more difficult it is to be creative.  One of the crucial skills you need to learn is when and how to place restrictions on yourself.  

Specs are a perfect example of self-imposed constraints that help enormously in producing a final product.  Without the structure of agreed-upon specs you would have to spend much more of your time remembering what you're doing and how it fits with the last piece you built.  

On the group level, specs are indispensible.  Without agreeing on specs before beginning to code, it's almost guarenteed that your team's code will not work when you piece it together.  By constraining yourselves to a set of specs, you are free as a group to take more liberties in implementation and workflow with the confidence that your project will work when everyone has finished their piece.

[TOP](#index)

___
## Common Constraints

Here's a quick look at the types of constraints a software developer will confront on a daily basis. While this list is written with developers in mind, you'll find that many of these sound familiar from your industry.

This list is long and it's not even near comprehensive.  Rather than looking it as an enormous list of shutdowns, try thinking of it as a bunch of decisions you don't have to make.  Free yourself!



Some common constraints when developing software:
* The audiences:
  * A user must understand your applicaiton.
  * Developers must understand your code.
  * Computers must run your code.
* Other people
  * Bad legacy code
  * Unpleasant team-mates
  * Bad junior developers
  * Even worse senior developers
  * Bad managers
  * Impossible customers
* Yourself
  * Skill/experience limitations
  * Tool familiarity
  * Bad work habits
  * Bad attitude
  * Poor team-working skills
* Development
  * Deadlines
  * Budgets
  * Specs
  * Unexpected changes in any of these
  * Architecture 
* Technology stacks:
  * Programming languages
  * Frameworks 
  * Lack of frameworks
  * Compatibility
* Hardware, yours and users:
  * Speed
  * Price
  * OS
* And so so many more ...

[TOP](#index)

___

## Decomposition

Problem decomposition is central to problem solving.  Being able to look at a large problem and understand it as many small problems strung together will make you a better human.  

Some of many advantages:      
* You have created helpful constraints.  Two smaller problems are easier to approach and will usually result in a higher quality finished product.  
* Collaboration becomes easier. You can split work with the guarentee that each person's contribution will be valuable.  
* It can guide the analysis phase.  Often the hardest question is how to start understanding a problem. by first decomposing a new problem, you can skip being confused by how to start.  Decomposing is always worth your time.  
* Smaller pieces are easier to code.  Decomposing large problems brings them closer to code, making the trasition to a practical solution much simpler.  
* Apps built of smaller apps are almost always easier to test and maintain.  
  
I'm sure there are more benefits to breaking down large problems, but these should be enough to convince you.  

Getting good at this will just take practice.    
  
  
[TOP](#index)

___

## Activity

### Full class

i guide them through this process

### small groups

they practice it with a relevent case study

[TOP](#index)

___


## Resources


Analysis First:
* [Problem vs. Solution Oriented Thinking](http://www.planetofsuccess.com/blog/2011/problem-vs-solution-focused-thinking/)
* [rockefeller](https://www.rockefellerfoundation.org/blog/defining-problem-find-solution/)
* [analysis paralysis](https://en.wikipedia.org/wiki/Analysis_paralysis)
* [A3](http://www.heitmanagement.com/blog/2013/08/a3-thinking-understand-problems-before-trying-to-solve-them/)
* [managing to learn](https://www.lean.org/events/mtl_foreword_intro_chapt_1and2.pdf)
* [triz](https://en.wikipedia.org/wiki/TRIZ)
* [lesswrong](http://lesswrong.com/lw/ka/hold_off_on_proposing_solutions/)

Constraints:
* [from medium, david](https://medium.com/stanford-d-school/want-some-creativity-crank-up-the-constraints-5728a988a635)
* [creative constraints](https://ed.ted.com/lessons/the-power-of-creative-constraints-brandon-rodriguez)
* [From photography](http://erickimphotography.com/blog/2015/08/06/the-beauty-of-creative-constraints-in-photography/)
* [types of constraints](https://www.psychologytoday.com/blog/beautiful-minds/201108/does-creativity-require-constraints)
* [wired, to sciency?](https://www.wired.com/2011/11/need-to-create-get-a-constraint/)
* [forbes](https://www.forbes.com/sites/groupthink/2013/07/12/creativity-how-constraints-drive-genius/#3aab55e33d89)


Problem Decomposition:
* [BBC decomposition](https://www.bbc.co.uk/education/guides/zqqfyrd/revision/3) 
* [BBC algorithms](https://www.bbc.co.uk/education/guides/zpp49j6/revision)


___
___
### <a href="http://elewa.education/blog" target="_blank"><img src="https://user-images.githubusercontent.com/18554853/34921062-506450ae-f97d-11e7-875f-6feeb26ad72d.png" width="100" height="40"/></a>